\label[chap:implementation] 
\chap Program Implementation

This chapter describes the implemented prototype.

TODO

\midinsert \clabel[pic:sowl-crowler-stack]{Overview of the whole stack and files exchanged}
\picw=12cm \cinspic sowl-crowler-stack.png
\caption/f Overview of the whole stack and files exchanged
\endinsert

\sec SOWL implementation

During testing of various technologies and frameworks several prototypes of the 
scenario creator was built. The first one called SelectOWL was native Firefox
addon build on XUL and calls to Firefox low level API. Development of SelectOWL
was discontinued in favour of new addon with shortened name SOWL. The new 
addon is based on Firefox addon SDK. The structure of the addon is completely 
different from the original one and the JavaScript of the addon runs in
different context too. The new SDK is the recommended approach now and offers
more flexible functionality and more intuitive code structure as the user
interface is defined using classical HTML instead of XUL. The original version
is kept in the repository for reference
\urlnote{https://github.com/kub1x/selectowl/tree/master/ff-extension}. 


\secc Parsing Ontologies in JavaScript

Both jOWL vs rdfQuery were tested on common ontologies (FOAF, Dublin Core, Good
Relations). Results shown that the newer rdfQuery library more accurately implements
the standard behavior for handling RDF resources.

Specifically in jOWL all resources have only one type. This type is determined
when parsing input XML fileby a lookup cascade: if the type is not determined
by the explicit RDF type property, the parser would look into the overlying tag
name. 

rdfQuery, on the other hand, properly stores all the data in form of triples in its 
internal dataset implementation. By using this approach it offers correct results
and is our library of choice. 

Even though rdfQuery currently serves for parsing of input files only, we might
consider utilizing its reasoning capabilities in future development. 


\secc Targeting elements on webpage and generating selectors

Inspired by the InfoCram project we decided to use Aardvark code in order to 
target elements on webpage and obtain their selectors. 

In early stages the native addon code for Aardvark was used. Unfortunately this
code uses some internal Firefox API and had to be replaced when new Firefox SDK
was used for the SOWL development. 

In current Implementation of SOWL we create different type of Firofox extension
using new SDK. Moreover the aardvark code is injected directly into the webpage
using the Content Script feature of the Firefox SDK. According to these
differences the bookmarklet version better fits the needs and is used. The
aardvark code is included in the addon files extended with features necessary
for SOWL. Namely the event handling was extended by drag/drop events and 
selector creation algorithm was added. 

The selector creation was implemented as specified in XXX design->selector
creation XXX.  Even though it was rewritten it behaves almost identically as in
InfoCram. We simply bubble up the DOM tree until we meet our context. On each
element we try to generate unique selector according to the element's parent
element. The last method to try is the {\tt :nth-child()} selector which always
exists and targets the correct element, but is also most prone to failures due
tu structure changes. If possible ID or class attributes are used to target the
element. 

As use case 2 XXX shown we can not always rely on class selectors as they are 
often dynamically modified by pages JavaScript. For this reason the class
selector are disabled by default, but they are supported by crOWLer and can be
manually specified in the selector field. Aardvark shows the class of a hovered
element on its label to simplify this task. 


\sec crOWLer implementation

Scenario based on Strigil/XML syntax (or its JSON alternative) is not directly 
translatable into the original crOWLer configuration. 

XXX example of Strigil XML that can not be parsed into crOWLer configuration

A new structure was implemented holding a Scenario object with its steps.  In
this form the Scenario is passed to main loop. Instead of {\tt FullCrawler}
based on JSOUP we created WebDriver based solution, the {\tt WebDriverCrawler}. 


\secc architecture

XXX include class diagram..?


%\secc Implemented and unimplemented capabilities
%
%XXX

